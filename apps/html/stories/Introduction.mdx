<div className="sb-unstyled cdr-prose cdr-prose--sm c1-story-pad-24 c1-story-max-640">

<h1 className="cdr-title">Cedar One</h1>
{/* 
<div className="cdr-not-prose c1-story-mt-8">
  <ul className="cdr-list cdr-list--inline cdr-list--compact cdr-list--unordered cdr-eyebrow">
    <li>
      <a className="cdr-link" href="https://github.com/rei/rei-cedar-one">
        GitHub
      </a>
    </li>
    <li>
      <a className="cdr-link" href="https://rei.github.io/rei-cedar-one/vue">
        Vue Storybook
      </a>
    </li>
    <li>
      <a className="cdr-link" href="https://rei.github.io/rei-cedar-one/react">
        React Storybook
      </a>
    </li>
  </ul>
</div> */}

Cedar One provides a framework-agnostic, CSS-first foundation for <a className="cdr-link" href="http://cedar.rei.com">Cedar</a>.
Tokens define design intent. Components ship as native HTML and static CSS, with behavior added only when needed.

### A CSS-first component system

```html
<button class="cdr-button cdr-button--primary" type="button">
  Add to cart
</button>
```

Result: <button type="button" className="cdr-button cdr-button--primary">{`Add to cart`}</button> — no runtime JavaScript required.

### Contracts, enforced before runtime

Instead of shipping validation logic inside framework components, Cedar One enforces
component contracts at development and build time using ESLint and tooling.

<h4 style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
  <svg
    aria-hidden="true"
    focusable="false"
    className="cdr-icon cdr-icon--large"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    style={{ '--cdr-icon-fill-default': 'var(--cdr-color-text-input-error)' }}
  >
    <use href="#x-stroke" />
  </svg>
  <span>Runtime validation</span>
</h4>

Runtime validation increases shipped JavaScript and expands the surface area to maintain:

```ts
import { defineProps } from 'vue';

defineProps({
  variant: {
    type: String,
    validator: (value) => ['primary', 'secondary', 'dark'].includes(value),
  },
});
```

<h4 style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
  <svg
    aria-hidden="true"
    focusable="false"
    className="cdr-icon cdr-icon--large"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    style={{ '--cdr-icon-fill-default': '#3b8349' }}
  >
    <use href="#check-stroke" />
  </svg>
  <span>Development-time validation</span>
</h4>

So we keep runtime lean and push checks earlier. Here’s what an unknown modifier looks like:

```ts
const BASE = 'cdr-button';

function lintButtonClassList(classList: string[]) {
  assertHasBaseClass(classList, BASE);
  for (const cls of classList) {
    if (cls.startsWith(`${BASE}--`) && !isKnownModifier(cls)) {
      reportUnknownModifier(cls);
    }
  }
}
```

Example (typo):

```html
<button class="cdr-button cdr-button--prmiary" type="button">
  Add to cart
</button>
```

Result:

<img
  className="cdr-image cdr-image--fit-contain cdr-image--radius-softer"
  src="assets/lint-error.png"
  alt="Example ESLint error showing an unknown Cedar One class modifier."
/>

### Adapters at the edges

We only reach for JavaScript when <a href="./?path=/docs/html-disclosure-accordion--docs">behavior</a> is unavoidable and CSS can’t cover the gap.

Those behaviors live in small, framework-agnostic adapters that Vue and React can wrap when needed.

In HTML, attach an adapter to the rendered DOM:

```ts
import { createAccordionAdapterFromElement } from '@rei/c1-ui/adapters/accordion';

document
  .querySelectorAll<HTMLElement>('.cdr-accordion')
  .forEach((element) => createAccordionAdapterFromElement({ element }));
```

In Vue and React, composables wire refs and lifecycle while reusing the same headless core:

```ts
import { useAccordionAdapter } from '@rei/c1-ui/adapters/accordion/vue';

useAccordionAdapter({ refs, state });
```

### Design principles

Cedar One is guided by a small set of system-level principles that shape how components are authored, validated, and shipped.

- **Single source of truth**: Tokens define design intent once and drive outputs across platforms.
- **Static by default**: HTML and CSS are preferred over runtime abstractions wherever possible.
- **Validation before shipping**: Component contracts are enforced during development, not in production.
- **Usage-driven output**: Builds can generate only the utilities and recipes a project actually uses.
- **Performance by default**: Smaller bundles, reduced runtime work, and predictable rendering are treated as first-class outcomes of the system.

Together, these principles keep the system portable, predictable, and performant as platforms and frameworks evolve.

</div>
